// working code with api not call again without edit input but in this checkbox logic was mine 
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Editor, EditorState, ContentState, convertFromRaw, convertToRaw } from 'draft-js';
import ListOnlyEditor from 'imports/generator/ui/pages/ListOnlyEditor';
import { useMutation } from 'react-apollo';
import { UPDATE_BLOCK_ITEM_FIELD, ADD_BLOCK_ITEM } from '/imports/generator/api/apollo/client/mutations';
import { useReviewStore } from '/zustand/dataFetchZustand';
import { FetchDataFromApi } from 'imports/checkout/api/helpers';
import styled from 'styled-components';
import { blockItemImmutableUpdate } from '/imports/generator/api/apollo/client/helpers';

const AIReviewSection = ({ resumeId, token, onUpdateComplete, onRefreshRef, onResumeUpdate }) => {
  const {
    reviewData,
    setReviewData,
    errorReview,
    setError,
    loadingReview,
    setLoading,
    hasFetched,
    editorStates,
    setEditorState,
    inputValues,
    setInputValue,
    createdItems,
    setCreatedItem,
    checkedItems,
    setCheckedItem,
    setAllCheckedItems,
    clearAllCreatedItems,
    appliedItems,
    setAppliedItem,
    clearAllAppliedItems,
  } = useReviewStore();

  const [updateBlockItemField] = useMutation(UPDATE_BLOCK_ITEM_FIELD);
  const [addBlockItem] = useMutation(ADD_BLOCK_ITEM);
  const [isFirstRender, setIsFirstRender] = useState(true);

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      const data = await FetchDataFromApi({ resumeId }, token);
      // console.log('ðŸŒ Fetch success:', data);

      clearAllCreatedItems();
      clearAllAppliedItems();
      // ðŸ†• Clear baseline ref
      baselineValuesRef.current = {}; 

      const initialCheckedItems = {};
      const initialInputValues = {};
      const initialEditorStates = {};

      data.edits.forEach((edit, index) => {
        const key = edit.isNewItem ? `${edit.blockId}_${edit.field}_${index}` : `${edit.itemId}_${edit.field}`;
        initialCheckedItems[key] = true;

        const newValue = typeof edit.newValue === 'string' ? edit.newValue : JSON.stringify(edit.newValue);

        if (edit.field === 'description') {
          initialEditorStates[key] = newValue;
        } else {
          initialInputValues[key] = extractPlainText(newValue);
        }
        
      });

      setReviewData(data);
      Object.entries(initialEditorStates).forEach(([k, v]) => setEditorState(k, v));
      Object.entries(initialInputValues).forEach(([k, v]) => setInputValue(k, v));
      setAllCheckedItems(initialCheckedItems);
      setLoading(false);
    } catch (err) {
      console.error('âŒ Fetch failed:', err);
      setError(err.message);
      setLoading(false);
    }
  }, [
    resumeId,
    token,
    loadingReview,
    setReviewData,
    setLoading,
    setError,
    setEditorState,
    setInputValue,
    setAllCheckedItems,
    clearAllCreatedItems,
    clearAllAppliedItems,
    // extractPlainText,
  ]);

  useEffect(() => {
    // Only clear createdItems when component unmounts or resumeId changes
    return () => {
      // console.log('ðŸ§¹ Clearing createdItems cache on unmount');
       clearAllCreatedItems();
       clearAllAppliedItems();
    };
  }, []); // Clear when resumeId changes

  useEffect(() => {
    if (isFirstRender && !hasFetched) {
      // console.log('ðŸ”„ First time AI Review - fetching data');
      fetchData();
      setIsFirstRender(false);
    }
  }, [isFirstRender, hasFetched]);

  useEffect(() => {
    if (onRefreshRef) onRefreshRef.current = fetchData;
  }, [fetchData, onRefreshRef]);

  const handleCheckbox = useCallback((key) => setCheckedItem(key, !checkedItems[key]), [checkedItems, setCheckedItem]);

  const handleGroupCheckbox = useCallback(
    (groupKey, itemKeys) => {
      const allSelected = itemKeys.every((k) => checkedItems[k]);
      itemKeys.forEach((k) => setCheckedItem(k, !allSelected));
    },
    [checkedItems, setCheckedItem],
  );

  const handleToggleSelectAll = useCallback(() => {
    const allSelected = Object.values(checkedItems).length > 0 && Object.values(checkedItems).every(Boolean);

    const updated = {};
    // Object.keys(checkedItems).forEach((key) => (updated[key] = !allSelected));
    if (reviewData?.edits) {
      reviewData.edits.forEach((edit, index) => {
        const key = edit.isNewItem ? `${edit.blockId}_${edit.field}_${index}` : `${edit.itemId}_${edit.field}`;
        updated[key] = !allSelected;
      });
    }
    setAllCheckedItems(updated);
  }, [checkedItems, setAllCheckedItems]);

  const allSelected = Object.values(checkedItems).length > 0 && Object.values(checkedItems).every(Boolean);
  const toggleLabel = allSelected ? 'Deselect All' : 'Select All';

  const handleEditorChange = useCallback(
    (key, value) => {
      const content = value && typeof value === 'object' && 'target' in value ? value.target.value : value;
      setEditorState(key, content);
      if (appliedItems[key]) {
        setAppliedItem(key, false);
      }
    },
    [setEditorState, appliedItems, setAppliedItem],
  );

  const handleInputChange = useCallback(
    (key, eventOrValue) => {
      let newVal;

      if (eventOrValue?.target?.value !== undefined) {
        newVal = eventOrValue.target.value;
      } else {
        newVal = eventOrValue;
      }

      setInputValue(key, newVal);
      if (appliedItems[key]) {
        setAppliedItem(key, false);
      }
    },
    [setInputValue, appliedItems, setAppliedItem],
  );

  const ReadOnlyDraft = ({ rawContent }) => {
    try {
      const parsed = typeof rawContent === 'string' ? JSON.parse(rawContent) : rawContent;

      const contentState = convertFromRaw(parsed);
      const editorState = EditorState.createWithContent(contentState);
      return <Editor editorState={editorState} readOnly={true} />;
    } catch (error) {
      return <div>{String(rawContent)}</div>;
    }
  };

  const extractPlainText = (value) => {
    if (!value) return '';

    // If it's already a string and not a JSON string, return as is
    if (typeof value === 'string') {
      // Check if it's a JSON string that needs parsing
      if (value.trim().startsWith('{') || value.trim().startsWith('[')) {
        try {
          const parsed = JSON.parse(value);
          return extractPlainText(parsed);
        } catch {
          return value;
        }
      }
      return value;
    }

    // If it's an object (including arrays)
    if (typeof value === 'object' && value !== null) {
      // Handle Draft.js content
      if (value.blocks && Array.isArray(value.blocks)) {
        return value.blocks.map((b) => b.text).join('\n');
      }
      //  Handle social links or other complex objects
      if (value.url || value.link || value.href) {
        return value.url || value.link || value.href || '';
      }
      // if (value.url || value.link || value.href) {
      //   // For social links, return a formatted string showing both
      //   const url = value.url || value.link || value.href || '';
      //   const label = value.label || value.name || '';
      //   return JSON.stringify({ url, label });
      // }
      // Handle arrays
      if (Array.isArray(value)) {
        return value.map((item) => extractPlainText(item)).join(', ');
      }
      // Try to find meaningful string values in the object
      const stringValues = Object.values(value)
        .filter((v) => typeof v === 'string' && v.trim() !== '')
        .map((v) => v.trim());

      if (stringValues.length > 0) {
        return stringValues.join(', ');
      }
      return JSON.stringify(value);
    }
    return String(value);
  };

  const baselineValuesRef = useRef({});

  const hasFieldBeenModified = useCallback(
    (key, edit) => {
      if (appliedItems[key]) {
        const currentValue = edit.field === 'description' ? editorStates[key] : inputValues[key];

        // Use baseline from ref, fallback to original AI value
        const baselineValue = baselineValuesRef.current[key] || extractPlainText(edit.newValue);

        let normalizedCurrent;
        let normalizedBaseline;

        if (edit.field === 'description') {
          normalizedCurrent = extractPlainText(currentValue);
          normalizedBaseline = extractPlainText(baselineValue);
        } else {
          normalizedCurrent = String(currentValue || '').trim();
          normalizedBaseline = String(baselineValue || '').trim();
        }
        return normalizedCurrent !== normalizedBaseline;
      }
      console.log('ðŸ” Not applied yet, needs processing');
      return true;
    },
    [appliedItems, editorStates, inputValues, extractPlainText],
  );


  const needApiCall = useCallback((checkedKeys) => {
     if (!reviewData?.edits) return false;
      // console.log('ðŸ” Checking if API call needed for keys:', checkedKeys);
  
    for(const key of checkedKeys){
      const edit = reviewData?.edits.find((e,i) => {
        const matchKeys = e.isNewItem ? `${e.blockId}_${e.field}_${i}` : `${e.itemId}_${e.field}`
        return matchKeys === key
      })
       if (edit) {
         const needsCall = hasFieldBeenModified(key, edit);
        //  console.log(`ðŸ” Key ${key} needs API call:`, needsCall);
         if (needsCall) {
           return true;
         }
       } else {
         console.log(`ðŸ” No edit found for key: ${key}`);
       }
    }
     console.log('ðŸ” No API calls needed for any checked items');
    return false
  },[reviewData, hasFieldBeenModified])

  const updateBlockItemLocal = useCallback(
    (blockId, itemId, field, value) => {
      if (!reviewData || !reviewData.blocks) {
        console.warn('âš ï¸ Skipping local update â€” no blocks in reviewData.');
        return;
      }

      const update = (newData, isGetter) => {
        if (isGetter) return structuredClone(reviewData);
        setReviewData(newData);
      };
      const updater = blockItemImmutableUpdate(update);

      updater(resumeId, blockId, itemId, field)(value);
      console.log('âš™ï¸ Locally updated block:', { blockId, itemId, field, value });
    },
    [resumeId, reviewData, setReviewData],
  );

  const getOrderedKeysForBlock = (blockType, newValueObj = {}) => {
    const desired =
      {
        SOCIAL_LINKS: ['label', 'url'],
      }[blockType] || [];

    const allKeys = Object.keys(newValueObj);
    const remaining = allKeys.filter((k) => !desired.includes(k));
    return [...desired, ...remaining];
  };

  const handleApplyAllChanges = useCallback(async () => {
    const checkedKeys = Object.keys(checkedItems).filter((key) => checkedItems[key]);

    if (checkedKeys.length === 0) {
      alert('Please select at least one checkbox');
      return;
    }

    // console.log('ðŸ” Starting apply changes with keys:', checkedKeys);
    // console.log('ðŸ” Current appliedItems:', appliedItems);

    if(!needApiCall(checkedKeys)){
      // console.log('ðŸ”„ No changes detected, updating UI state only');
       checkedKeys.forEach((key) => {
         setAppliedItem(key, true);
       });

       setAllCheckedItems({});

       if (onUpdateComplete) {
         onUpdateComplete();
       }
       return;
    }

    try {
       let hasChanges = false;

      for (const key of checkedKeys) {
        const edit = reviewData.edits.find((e, i) => {
          const matchKey = e.isNewItem ? `${e.blockId}_${e.field}_${i}` : `${e.itemId}_${e.field}`;
          return matchKey === key;
        });
        
        if (!edit) continue;

         // ðŸ†• CHECK: Skip if this item was already applied and not modified
        if (appliedItems[key] && !hasFieldBeenModified(key, edit)) {
          console.log('â­ï¸ Skipping already applied item:', key);
          continue;
        }

        let currentValue;

        if (edit.field === 'description') {
          const editorValue = editorStates[key];
          if (editorValue === undefined) {
            console.log('âš ï¸ Missing editor value for key:', key);
            continue;
          }
          // console.log('ðŸ“ Editor value for description:', editorValue);
          if (typeof editorValue === 'string' && editorValue.includes('"blocks"')) {
            currentValue = editorValue;
          } else if (typeof editorValue === 'string') {
            const contentState = ContentState.createFromText(editorValue);
            currentValue = JSON.stringify(convertToRaw(contentState));
          } else {
            currentValue = typeof edit.newValue === 'string' ? edit.newValue : JSON.stringify(edit.newValue);
          }
        } else {
          // currentValue = inputValues[key] || extractPlainText(edit.newValue);
          currentValue = inputValues[key] !== undefined ? inputValues[key] : extractPlainText(edit.newValue);
        }

        if (edit.isNewItem) {
          const existingItemId = createdItems[key];

          let itemIdToUse = existingItemId;
          if (!itemIdToUse) {
            try {
              const addResponse = await addBlockItem({
                variables: {
                  resumeId,
                  blockId: edit.blockId,
                  animationKey: `new-item-${Date.now()}`,
                },
              });
              // console.log('ðŸ†• addBlockItem response:', addResponse);

              itemIdToUse = addResponse.data.addBlockItem.itemId;

              if (!itemIdToUse) {
                // console.log('âŒ Failed to retrieve new itemId after creation.');
                continue;
              }
              setCreatedItem(key, itemIdToUse);
              hasChanges = true;
            } catch (err) {
              console.error('âŒ Error creating new block item:', err);
              continue;
            }
          } else {
            console.log('ðŸ”„ Using existing created item ID:', itemIdToUse, 'for key:', key);
          }

          let valuesToStore = {};

          if (typeof edit.newValue === 'object' && edit.newValue !== null) {
            // Use the user-edited object directly if available
            const editedObj = inputValues[key];
            valuesToStore = typeof editedObj === 'object' ? editedObj : edit.newValue;
          } else {
            const fieldForSingleValue = edit.field !== 'new-field' ? edit.field : 'value';
            valuesToStore[fieldForSingleValue] = inputValues[key] ?? extractPlainText(edit.newValue);
          }

          for (const fieldKey in valuesToStore) {
            const value = valuesToStore[fieldKey];
            if (value == null || value === '') continue;

            let finalValue = value;

            if (typeof value === 'object' && !Array.isArray(value)) {
              finalValue = value;
            }
            // console.log('finalValue', finalValue);
            try {
              await updateBlockItemField({
                variables: {
                  docId: resumeId,
                  blockId: edit.blockId,
                  itemId: itemIdToUse,
                  field: fieldKey,
                  needUpdate: true,
                  value: finalValue,
                },
              });
              hasChanges = true
            } catch (updateError) {
              console.error('âŒ Error updating field:', fieldKey, updateError);
              if (updateError.message.includes('Block item ID not found')) {
                // console.log('ðŸ§¹ Clearing cache for not found item');
                setCreatedItem(key, null);
              }
            }
          }
        } else {
         
          updateBlockItemLocal(edit.blockId, edit.itemId, edit.field, currentValue);
          // console.log('goes inside');

          await updateBlockItemField({
            variables: {
              docId: resumeId,
              blockId: edit.blockId,
              itemId: edit.itemId,
              field: edit.field,
              value: currentValue,
              needUpdate: true,
            },
            update: (cache, res) => {
              if (res?.data?.updateBlockItemField) {
                updateBlockItemLocal(edit.blockId, edit.itemId, edit.field, currentValue);
              }
            },
          });
          hasChanges = true;
        }
          // console.log('âœ… Marking as applied after API call:', key);
           baselineValuesRef.current[key] = currentValue;
          setAppliedItem(key, true);
      }
      if (hasChanges) {
        console.log('âœ… Changes applied successfully with API calls!');
      } else {
        console.log('â„¹ï¸ No API calls needed - items already applied');
      }
      // console.log('âœ… All changes applied successfully!');
      setAllCheckedItems({});

      if (onResumeUpdate && hasChanges) {
        // console.log('ðŸ”„ Calling onResumeUpdate to refresh parent data');
        onResumeUpdate();
      }
      if (onUpdateComplete) {
        onUpdateComplete();
      } else {
        console.log('âš ï¸ onUpdateComplete is undefined');
      }
    } catch (error) {
      console.error('âŒ Error updating resume:', error);
      // FIX: Enhanced error handling
      if (error.message.includes('Block item ID not found')) {
        const match = error.message.match(/Block item ID not found: ([a-f0-9-]+)/);
        if (match) {
          const problematicItemId = match[1];
          console.log(`ðŸ”§ Clearing cache for problematic item: ${problematicItemId}`);

          // Clear the specific problematic item from cache
          Object.entries(createdItems).forEach(([cacheKey, cachedItemId]) => {
            if (cachedItemId === problematicItemId) {
              setCreatedItem(cacheKey, null);
              console.log(`ðŸ§¹ Cleared cache for key: ${cacheKey}`);
            }
          });
        }
      }
    }
  }, [
    checkedItems,
    reviewData,
    editorStates,
    inputValues,
    resumeId,
    updateBlockItemField,
    addBlockItem,
    onResumeUpdate,
    onUpdateComplete,
    createdItems,
    setCreatedItem,
    updateBlockItemLocal,
    setAllCheckedItems,
    extractPlainText,
    appliedItems,
    setAppliedItem,
    needApiCall,
    hasFieldBeenModified,
    fetchData,
    setReviewData,
  ]);

  if (loadingReview) return <LoadingText>Loading...</LoadingText>;
  if (errorReview) return <ErrorText>{errorReview}</ErrorText>;
  if (!reviewData) return <NoDataText>No data yet</NoDataText>;

  // group new items by blockId + field, using original index for stable keys
  const groupedNewItems = (reviewData?.edits || []).reduce((acc, edit, idx) => {
    if (!edit.isNewItem || edit.field === 'description') return acc;
    const groupKey = `${edit.blockId}_${edit.field}`;
    if (!acc[groupKey]) acc[groupKey] = { edits: [], firstIdx: idx };
    acc[groupKey].edits.push({ ...edit, originalIndex: idx });
    return acc;
  }, {});

  return (
    <MainWrapper>
      <SelectionBtnWrapper>
        <SelectAllbtn onClick={handleToggleSelectAll}>{toggleLabel}</SelectAllbtn>
      </SelectionBtnWrapper>

      <EditsList>
        {reviewData?.edits
          .filter((edit) => !edit.isNewItem)
          .map((edit, index) => {
            const key = edit.isNewItem ? `${edit.blockId}_${edit.field}_${index}` : `${edit.itemId}_${edit.field}`;
            const oldValue = typeof edit.oldValue === 'string' ? edit.oldValue : JSON.stringify(edit.oldValue);

            const displayValue =
              edit.field === 'description'
                ? editorStates[key] || extractPlainText(edit.newValue)
                : (inputValues[key] ?? extractPlainText(edit.newValue));

            return (
              <EditItem key={key}>
                <CheckboxInput
                  type="checkbox"
                  checked={checkedItems[key] || false}
                  onChange={() => handleCheckbox(key)}
                />
                <Suggestion>Suggestion {index + 1}</Suggestion>
                <EditContent>
                  <EditHeader>
                    <BlockType>{edit.blockType}</BlockType>
                  </EditHeader>

                  <ValuesContainer>
                    {!edit.isNewItem && (
                      <ValueSection>
                        <ValueLabel>Currunt Text:</ValueLabel>
                        <OldValueContainer>
                          <ValueText>
                            <ReadOnlyDraft rawContent={oldValue} />
                          </ValueText>
                        </OldValueContainer>
                      </ValueSection>
                    )}
                    {!edit.isNewItem && <ValueDivider />}

                    <ValueSection>
                      <ValueLabel>{edit.isNewItem ? 'New Block:' : 'Improved Text:'}</ValueLabel>
                      {edit.field === 'description' ? (
                        <EditorWrapper>
                          <ListOnlyEditor value={displayValue} onChange={(value) => handleEditorChange(key, value)} />
                        </EditorWrapper>
                      ) : (
                        <TextareaWrapper>
                          <HobbiesTextarea
                            value={displayValue}
                            onChange={(event) => handleInputChange(key, event)}
                           />
                        </TextareaWrapper>
                      )}
                    </ValueSection>
                  </ValuesContainer>
                </EditContent>
              </EditItem>
            );
          })}

        {Object.entries(groupedNewItems || {}).map(([groupKey, { edits, firstIdx }]) => {
          const firstEdit = edits[0];
          const groupLabel = `${
            firstEdit.blockType
              ? firstEdit.blockType.charAt(0).toUpperCase() + firstEdit.blockType.slice(1).toLowerCase()
              : ''
          }`;

          const groupItemKeys = edits.map((edit) => `${edit.blockId}_${edit.field}_${edit.originalIndex}`);

          const allGroupChecked = groupItemKeys.every((key) => checkedItems[key]);
          const someGroupChecked = groupItemKeys.some((key) => checkedItems[key]);

          return (
            <EditItem key={groupKey}>
              <NewContainer>
                <CheckboxInput
                  type="checkbox"
                  checked={allGroupChecked}
                  indeterminate={someGroupChecked && !allGroupChecked ? 'true' : undefined}
                  onChange={() => handleGroupCheckbox(groupKey, groupItemKeys)}
                  data-inline="true"
                />
                <Suggestion>Suggestion {firstIdx + 1}</Suggestion>
              </NewContainer>
              <NewSuggestion>Suggested: {groupLabel}</NewSuggestion>

              <EditContent>
                {edits.map((edit, i) => {
                  const key = `${edit.blockId}_${edit.field}_${edit.originalIndex}`;

                  return (
                    <NewValueSection key={key}>
                      <ToggleButton onClick={() => handleCheckbox(key)} checked={checkedItems[key] || false}>
                        {checkedItems[key] ? 'x' : '+'}
                      </ToggleButton>
                      <FieldSet>
                        <Legend>{groupLabel}</Legend>
                        <GroupedContainer>
                          {(() => {
                            let parsedValue = edit.newValue;
                            try {
                              parsedValue =
                                typeof edit.newValue === 'string' ? JSON.parse(edit.newValue) : edit.newValue;
                            } catch {
                              /* ignore */
                            }

                            // If it's an object with key-value pairs, render inputs dynamically
                            if (parsedValue && typeof parsedValue === 'object' && !Array.isArray(parsedValue)) {
                              const objValue =
                                inputValues[key] && typeof inputValues[key] === 'object'
                                  ? inputValues[key]
                                  : parsedValue;

                              return (
                                <UrlValueContainer style={{}}>
                                  {/* {Object.entries(objValue).map(([subKey, subValue]) => (
                                    <UrlFieldSet key={subKey}>
                                      <UrlLegend>{subKey}</UrlLegend>
                                      <UrlInput
                                        type="text"
                                        value={subValue || ''}
                                        onChange={(e) => {
                                          // console.log('Typing...', e.target.value);
                                          const updatedObject = {
                                            ...objValue,
                                            [subKey]: e.target.value,
                                          };
                                          handleInputChange(key, updatedObject);
                                        }}
                                      />
                                    </UrlFieldSet>
                                  ))} */}

                                  {getOrderedKeysForBlock(edit.blockType, objValue).map((subKey) => (
                                    <UrlFieldSet key={subKey}>
                                      <UrlLegend>{subKey}</UrlLegend>
                                      <UrlInput
                                        type="text"
                                        value={objValue[subKey] || ''}
                                        onChange={(e) => {
                                          // console.log('Typing...', e.target.value);
                                          const updatedObject = {
                                            ...objValue,
                                            [subKey]: e.target.value,
                                          };
                                          handleInputChange(key, updatedObject);
                                        }}
                                      />
                                    </UrlFieldSet>
                                  ))}
                                </UrlValueContainer>
                              );
                            }

                            // ðŸ§© Default fallback for primitive values
                            return (
                              <NonUrlFieldset>
                                <UrlLegend>{edit.field || 'Value'}</UrlLegend>
                                <UrlInput
                                  type="text"
                                  value={inputValues[key] ?? extractPlainText(edit.newValue)}
                                  onChange={(event) => {
                                    console.log('Typing...', event.target.value);
                                    handleInputChange(key, event);
                                  }}
                                />
                              </NonUrlFieldset>
                            );
                          })()}
                        </GroupedContainer>
                      </FieldSet>
                    </NewValueSection>
                  );
                })}
              </EditContent>
            </EditItem>
          );
        })}
      </EditsList>
      <ApplyButtonWrapper>
        <ApplyButton onClick={handleApplyAllChanges}>âœ… Apply Changes</ApplyButton>
      </ApplyButtonWrapper>
    </MainWrapper>
  );
};

export default AIReviewSection;

const MainWrapper = styled.div`
  text-align: center;
  padding: 20px;
  font-size: 16px;
`;

const UrlFieldSet = styled.fieldset`
  flex: 1;
  min-width: 150px;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 8px 10px 4px 10px;
  position: relative;
`;

const UrlLegend = styled.legend`
  font-size: 12px;
  color: #666;
  padding: 0 5px;
  margin-left: 8px;
`;

const UrlInput = styled.input`
  width: 100%;
  padding: 6px;
  border: none;
  outline: none;
  background: transparent;
`;

const NonUrlFieldset = styled.fieldset`
  width: 100%;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 8px 10px 4px 10px;
`;

const GroupedContainer = styled.div`
  flex: 1;
`;

const UrlValueContainer = styled.div`
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
`;

const ToggleButton = styled.button`
  background-color: ${({ checked }) => (checked ? '#ff4d4d' : '#28a745')};
  color: white;
  border: none;
  border-radius: 50%;
  width: 16px;
  height: 16px;
  font-size: 18px;
  line-height: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease-in-out;

  &:hover {
    transform: scale(1.1);
    opacity: 0.9;
  }
`;

const NewContainer = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
`;

const NewValueSection = styled.div`
  margin-top: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
`;

const FieldSet = styled.fieldset`
  width: 100%;
  text-align: left;
  border-radius: 6px;
`;

const Legend = styled.legend`
  text-align: left;
  margin-left: 8px;
  font-size: 12px;
  // fontWeight: bold;
`;

const SelectionBtnWrapper = styled.div`
  margin-bottom: 15px;
  display: flex;
  gap: 10px;
  justify-content: right;
`;

const NewSuggestion = styled.div`
  display: flex;
  margin-left: 25px;
  position: static;
  font-size: 16px;
  font-weight: 600;
`;

const SelectAllbtn = styled.button`
  padding: 8px 16px;
  background-color: #0070f3;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
`;

const DeselectAllbtn = styled.button`
  padding: 8px 16px;
  background-color: #6c757d;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
`;

const EditsList = styled.ul`
  list-style: none;
  padding: 0;
  margin: 0;
`;

const EditItem = styled.li`
  border: 1px solid #adabab;
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 15px;
  position: relative;
`;

const CheckboxInput = styled.input`
  position: absolute;
  cursor: pointer;
  left: 12px;
  top: 12px;
  &[data-inline='true'] {
    position: static;
    margin: 0;
  }
`;

const Suggestion = styled.div`
  position: absolute;
  left: 35px;
  font-weight: 500;
  font-size: large;
  top: 8px;
`;

const EditContent = styled.div`
  margin-left: 30px;
  text-align: left;
`;

const EditHeader = styled.p`
  font-weight: bold;
  border-bottom: 1px solid #7a7979;
  padding-bottom: 6px;
  margin-bottom: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 25px;
`;

const BlockType = styled.span`
  font-weight: bold;
`;

const ValuesContainer = styled.div`
  display: flex;
  justify-content: space-between;
  gap: 10px;
  /* background-color: #666464ff; */
`;

const ValueSection = styled.div`
  flex: 1;
  /* background-color: lightblue; */
  width: 2vw;

  /* padding-top: 10px;
  padding-bottom: 10px; */
`;

const ValueLabel = styled.strong`
  display: block;
  margin-bottom: 4px;
`;

const ValueText = styled.div`
  margin-top: 4px;
  white-space: pre-wrap;
  line-height: 1.4;
`;

const OldValueContainer = styled.div`
  border: 1px solid #ccc;
  max-height: 200px;
  min-height: 200px;
  overflow-y: auto;
  padding: 8px;
  border-radius: 6px;

  &::-webkit-scrollbar {
    width: 6px;
  }

  &::-webkit-scrollbar-thumb {
    background-color: #888;
    border-radius: 8px;
    border: 2px solid #f0f0f0;
  }
`;

const ValueDivider = styled.div`
  width: 1px;
  background-color: #646363;
  margin: 0 10px;
`;

const TextareaWrapper = styled.div`
  margin-top: 4px;
  max-height: 200px;
  min-height: 200px;
  border: 1px solid #ccc;
  border-radius: 6px;
  /* min-width: 10vw; */
  /* background-color: #575757ff; */
`;

const HobbiesTextarea = styled.textarea`
  width: 100%;
  padding: 8px;
  /* border: 1px solid #ccc; */
  /* border-radius: 6px; */
  font-family: inherit;
  font-size: inherit;
  line-height: 1.4;
  border: none;
  background-color: transparent;
  /* background-color: #464545ff; */
  min-height: 120px;
  resize: vertical;

  //here is the test 
  /* min-height: 120px;
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-wrap: break-word; */
  outline: none;

  /* &:empty:before {
    content: attr(placeholder);
    color: #999;
  } */
  //end test here 
`;

const EditorWrapper = styled.div`
  margin-top: 4px;
  border: 1px solid #ccc;
  /* min-height: 120px; */
  /* width: 15vw; */
  padding: 8px;
  /* background-color: #797575ff; */
  border-radius: 6px;
`;

const ApplyButtonWrapper = styled.div`
  text-align: right;
  margin-top: 20px;
  background-color: transparent;
  margin-bottom: 20px;
  border: none;
`;

const ApplyButton = styled.button`
  align-self: flex-end;
  background-color: #0070f3;
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;

  &:hover {
    background: #0058c9;
  }
`;

const LoadingText = styled.p`
  text-align: center;
`;

const ErrorText = styled.p`
  color: red;
  text-align: center;
`;

const NoDataText = styled.p`
  text-align: center;
`;
